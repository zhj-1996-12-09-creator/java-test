package com.company;


public class DesignPatterns {

    //图的实现
    //1.邻接矩阵实现2.邻接表
    /**无向图
     * 邻接矩阵：二维数组 a[j][m]=1或0,1代表有边，0代表无边
     * 邻接表：是一个数组和每一个数组的索引的都存着一个队列，a和b之间有边，可以叫a到b的边，也可以称作b到a的边
     * 图的搜索
     * 深度优化搜索：先找子节点，再找兄弟节点
     * 广度优先搜索
     *


 * http协议：超文本传输协议   HyperText Transfer Protocol
 * tcp/ip协议
 * 分层：
 * 应用层：决定向用户提供应用服务时通信活动（ftp【文件传输协议】DNS【域名系统】服务）HTTP也在该层
 * 传输层：传输层对上层应用层提供处于网络连接中的两个计算机之间的数据传输（—TCP[传输控制协议]UDP[用户数据报协议])
 * 网络层：用来处理网络流动的数据包，数据包是网络传输的最小数据单位，与对方计算机之间通过多个计算机或网络设备传输时，
 * 网络层的作用是在众多路线选择一条通信路线
 * 数据链路层：硬件
 *
 * IP协议：把各种数据包传送给对方，而要保证传送到对方那里（两个条件是IP地址和MAC地址）
 * 使用ARP协议凭借MAC地址进行通信，现实中，通信双方要经过多台计算机的中转和网络设备才能连接到对方。
 * ARP（Address Resolution Protocol）解析地址的协议，通过ip地址反查出对应的MAC地址
 *
 * TCP协议：位于传输层，具有可靠的字节流服务，所谓的字节流服务，是将大数据瓜分成报文段为单位的数据包，确保数据可靠真实的传给对方
 * 为了确保数据准确无误的 送达目标处，TCP协议采用三次握手策略，握手过程使用是SYN(synchronize)和ACK(acknowledgement)
 * 首先客户端发送一个SYN标志的数据包给对方，服务端返回一个SYN/ACK的数据包已表明收到，最后客户端返回一个ACK的数据包，代表握手结束
 * 如果握手过程莫名中断，会重试
 *
 *
 * DNS：位于应用层，域名解析服务，通过ip查找域名，或或反向查找
 *
 * URI:用字符串标识某一互联网资源。URL：标识资源的位置
 *
 * http协议
 * 客户端：请求协议：请求方法、请求URI、协议版本、可选请求的首部字段和内容实体
 * 响应报文：协议版本、状态码、状态码的原因短语、相应的首部字段、HTTP协是不保存状态协议
 * HTTP协议使用URI定位到资源让客户端
 * GET：获取资源
 * POST:传输实体主体
 * PUT：传输文件、但是有安全性问题。谁都可以上传
 * HEAD: 获得报文首部，不要主体、用于确认URI的有效性和资源更新时间
 * DELETE:删除文件、不带检验
 * OPTIONS：询问URI支持的方法
 *
 * 持久连接：意在建立1次TCP连接后进行多次请求响应的互动、减少了TCP连接的重复建立和销毁的时间和
 * 资源
 * 管线化：同时并行多个http请求
 * Cookie：第一次请求，在服务端生成cookie，并且返回给客户端，下一次请求，请求报文则带着cookie信息
 *
 * 状态码告知从服务端返回的请求结果
 * 2XX：成功
 * 3xx：重定向
 * 4xx：客户端错误码
 * 5xx：服务端错误码
 *


 * leetCODE:交换工资
 * 方法一、IF二值判断
 * UPDATE salary SET sex = IF(sex='m','f','m')
 * 方法二、REPLACE（参考@山如是）
 * UPDATE salary SET sex = REPLACE('mf',sex,"") WHERE sex <> ""
 * 方法三 CASE选择
 * UPDATE salary
 * SET sex = (
 * CASE
 * WHEN sex = 'm' THEN 'f'
 * ELSE 'm'
 * END
 * )
 *
 * REGEXP_LIKe ('字段名'，v1|v2) 可以单个字段模糊匹配多个值=======oracle
 * regexp  v1|v2 ====mysql使用正则匹配多个字段
 *
 *
 *
 *
 * HashMap java8 底层实现
 * DEFAULT_INITIAL_CAPACITY ---默认初始容量--16
 * DEFAULT_LOAD_FACTOR----默认偏移量----0.75f
 * TREEIFY_THRESHOLD -----链成树最大结点树
 * UNTREEIFY_THRESHOLD ----树成链最小结点数
 * hash算法：(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)
 * put时的逻辑：1.整个map都是null，直接存
 *            2.存入的key在数组中唯一，直接存
 *            3.要存入的key和原有的key冲突，哈希冲突，那就在这个数组该索引处的使用链表的尾插法来插入新结点，
 *            判断链表中结点个数，超过了8个的话，就构建一个红黑树
 *            4.如果hash冲突，还是树的话，就用红黑树的方法添加树结点
 *            5.最后判断是否要扩容
 *
 *
 * spring 对bean的管理细节
 *          1.创建bean的三种方式
 *             使用默认构造函数创建
 *             在spring的配置文件中只有bean标签，配置了id和class属性，且没有其他标签时，使用默认构造函数
 *             使用某个类中的方法创建对象，
 *             <bean id="" class=""></bean>
 *             <bean id="" factory_bean="" factory_method=""></bean>
 *             使用某个类静态方法
 *             <bean id="" class="" fatory_method=""></bean>
 *          2.bean对象的作用范围
 *              bean 标签的scope属性
 *                  作用：bean的作用范围
 *                  取值：
 *                  singleton :单例
 *                  prototype ：多例
 *                  global session ：全局session
 *                  session ：作用域web应用会话
 *                  request：作用web应用的请求范围
 *
 *          3.bean对象的生命周期
 *                 单例对象：
 *                 出生：当容器创建时对象出生
 *                 活着：容器还在，对象就在
 *                 死亡：容器销毁，对象销毁
 *                 多例对象
 *                 出生：当我们使用对象时创建对象
 *                 活着： 对象使用过程中
 *                 死亡：当对象长时间不用，且没有别的对象使用，用java的垃圾回收器
 *
 *          spring中依赖注入
 *                  Dependency Injection
 *                IOC的作用：
 *                      降低程序间的耦合
 *                依赖关系的管理：
 *                      交由spring维护
 *                依赖关系的维护就叫依赖注入
 *                能注入类型--
 *                      基本类型和String
 *                      其他bean类型
 *                      复杂类型、集合类型
 *                   注入方式：
 *                   构造函数注入：
 *                          使用的标签constructor-arg
 *                          标签的位置：bean标签的内部
 *                          标签中属性：
 *                              type：用于给要注入的数据类型，该数据类型也是构造函数中某个
 *                              index：用于指定索引位置赋值
 *                              name：用于指定名称赋值
 *                              ===
 *                              ref：其他bean类型，在IOC容器配置过的
 *                              value：用于指定基本数据类型和String
 *                          优势：
 *                              在获取bean对象，注入bean对象必须提供参数
 *                          缺点：
 *                              改变了实例化方式，如果创建对象时用不到这些参数，
 *                  set方法注入：
 *                        标签：property
 *                        属性：
 *                          name：用于注入时的set方法名称
 *                          value：
 *                          ref：同上
 *
 *                  复杂类型的注入：结构相同，标签可以互换
 *                         <bean>
 *                             <property>
 *                                 <array>
 *                                     <value>Aa</value>
 *                                 </array>
 *                                 <map>
 *                                     <entry key="" value=""></entry>
 *                                 </map>
 *                             </property>
 *                         </bean>
 *
 *
 *
 *       注解：
 *       1.用于创建对象：
 *       Component:将当前类对象存入spring容器内
 *
 *       2.注入数据：
 *       Autowired:自动按照类型，只要IOC容器中有唯一一个bean对象类型，和要注入的一致
 *       如果有多个匹配时，再使用变量名称和bean的id一致也可以注入成功
 *       无匹配，报错
 *       Qualifier:和上面一起使用
 *       在按照
 *       Resource：
 *          属性：
 *          name：bean的id
 *       Value：
 *       注入基本类型和String
 *       属性：
 *          value：可以使用spring的spEL表达式：${表达式}
 *        3.用于改变作用范围
 *        Scope：
 *        属性：singleton：单例
 *        4.生命周期
 *        PreDistroy：用于指定销毁方法
 *        PostConstroct：用于指定初始化方法
 *
 *        容器相当于是一个MAP
 *        测试重复代码
 *        xml文件去掉
 *        Component-scan
 *        datasourse
 *          Configuration：当前类是配置。当配置类作为
 *          Import：加载其他配置类子节码
 *          ComponentScan：通过注解Ioc容器创建要扫描的包（value=“”）（basePackages=“”）
 *          等同于在xml配置Component-Scan
 *
 *        Bean：用于把当前方法的返回值作为返回值存入IOC容器中
 *              name：指定bean的id，默认值当前方法的名称
 *        细节：使用注解配置方法，如果有参数，会去容器中查找有没有可用的bean和Autowired一致
 *        PropertySource
 *          用于配置文件的
 *          value：classPath：
 *
 *          导入spring整合junit的jar
 *          spring-Test
 *
 *
 *
 *          synchronized：锁
 *          放在方法上
 *          放在静态方法上
 *          放在方法内部
 *
 *          锁：的几种状态
 *              1、无锁状态
 *              2.偏向锁状态
 *              3、轻量级锁状态
 *              4.重量级锁状态
 *          锁升级很容易，降级很难
 *          降级一般发生在stop the world 时期
 *
 *          java的锁都是基于对象的，每个java都有头对象，如果是非数组类型，2个字宽来存储头对象，如果是数组，则用3个字宽来存储头对象
 *          在32位处理器、一个字宽是32位的在64位虚拟机中，一个字宽是64位的
 *
 *          偏向锁：锁不仅存在多线程竞争，而且总是由统一线程多次获得，但是偏向锁会偏向第一个访问它的线程。偏向锁在无锁情况下消除了
 *          同步语句，连CAS操作都不做了，提⾼了程序的运⾏性能。
 *
 *          CAS:(Compare And Swap)比较并设置，用于设置硬件层面提供原子性
 *
 *          设计模式：
 *              一。Single Responsibility Principle：单一职责原则
 *                  类的职责应该单一、一个类只做一件事
 *              二。Open Closed Principle：开闭原则
 *                  所有引用基类的地方、必须能够使用其子类做替换
 *                      子类必须实现父类的所有方法 （继承的特性，子类拥有父类的所有方法）
 *                      子类可以有自己的个性 （重写）
 *                      覆盖或实现父类的方法时，入参可以放大（如：父类的参数 HashMap , 子类参数可以为 Map);
 *                      输出可以被缩小（如父类 return Map, 子类 return HashMap
 *              三。Liskov Substitution Principle：里氏替换原则
 *              四。Law of Demeter：迪米特法则
 *              五。Interface Segregation Principle：接口隔离原则
 *                   一个对象应该对其他对象有最少的了解。对类的低耦合提出了明确的要求
 *              六。Dependence Inversion Principle：依赖倒置原则
 *                      高层模块不应该依赖底层模块，两者都应该依赖其抽象. 不可分割的原子逻辑就是低层模式，原子逻辑组装成的就是高层模块。
 *                      抽象不应该依赖细节 java 中，抽象 -> 接口或抽象类；细节 -> 实现类
 *                      细节应该依赖抽象
 *
 *
 * String：适用于少量的字符串操作的情况，
 * StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况，
 * StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况
 *
 * java中的锁
 *      synchronized 关键字
 *      java.util.concurrent.Lock （Lock是一个接口，ReentrantLock是该接口一个很常用的实现）
 *
 *java多线程
 * 进程：应用程序在内存分配的内存空间，即正在运行的程序
 * cpu采用时间片轮换方法运行进程，cpu为每个进程分配时间断，称作他的时间片。如果时间片结束了进程还未结束，则暂时
 * 停这个进程，并且将时间【片分配给下一个进程，此过程叫做进程的上下文切换。如果在时间片结束或暂停前，进程结束。则cpu
 * 立即进行切换，不用等待时间片用完
 *
 * 进程和线程的区别：
 * 一、进程单独占有一定的内存空间，所以进程间存在内存隔离。数据是分开的，数据共享复杂但同步简单，哥各个进程间互不干扰，
 * 而线程共享所属进程的内存地址空间和资源。数据共享简单，但是同步复杂。
 * 二、进程单独占有一定的内存空间、一个进程出现问题不会影响其他进程。不影响主进程。可靠性高。一个线程的崩溃可能影响整个程序的
 * 稳定性。可靠性低。
 * 三、进程的创建不仅需要保存寄存器和栈信息，还需要资源的分配一级页调度，开销较大；线程只需要保存寄存器和栈信息
 *
 * 进程是操作系统进⾏资源分配的基本单位，⽽线程是操作系统进⾏调度的基本单位，即CPU分配时间的单位
 *
 * 上下文切换：
 * cpu从一个进程切换到另一个进程。上下文是指某一时间点cpu寄存器和程序计数器的内容
 *
 * 寄存器是cpu内部的少量的速度很快的闪存，通常存储和访问计算过程的中 间值提⾼计算机程序的运⾏速度。
 * 程序计数器是⼀个专⽤的寄存器，⽤于表明指令序列中 CPU 正在执⾏的位 置，存的值为正在执⾏的指令的位置或者下⼀个将要被执⾏
 * 的指令的位置， 具体实现依赖于特定的系统
 *
 * 上下文切换越多越不好，减少上下文切换的次数是多线程优化的课题
 *
 * 多线程编程的几个类：
 * Runnable接口和Thread类：多使用Runnable。java是单继承、多实现、优先使用Runnanble接口
 *
 *想要获得返回值：异步
 * Callable、Future与FutureTask
 *
 * ExecutorService和Callable配合使用
 *
 * ExecutorService executor = Executors.newCachedThreadPool();
 *  Task task = new Task();
 *  Future<Integer> result = executor.submit(task);
 *  // 注意调⽤get⽅法会阻塞当前线程，直到得到结果。
 *  // 所以实际编码中建议使⽤可以设置超时时间的重载get⽅法。
 *  System.out.println(result.get());
 *
 *  FutureTask能 够在⾼并发环境下确保任务只执⾏⼀次。这
 *
 *  线程组和线程（Thread Group And Thread）
 *  线程组对线程进行批量的控制Thread不能独立于Thread Group存在
 *  Thread.currentThread().getThreadGroup().getName());
 *  ThreadGroup管理着它下⾯的Thread，ThreadGroup是⼀个标准的向下引⽤的树状 结构，
 *  这样设计的原因是防⽌"上级"线程被"下级"线程引⽤⽽⽆法有效地被GC回 收。
 *
 *  线程的优先级
 *  java现成的优先级可以指定范围是1-10
 *  ⾼优先级的线程将会⽐低优先级的线程有更⾼的⼏率得到执⾏。我们 使⽤⽅法 Thread 类的 setPriority()
 *  实例⽅法来设定线程的优先级。
 *
 *
 *  Java提供⼀个线程调度器来监视和控制处于RUNNABLE状态的线程。线程的调度 策略采⽤抢占式
 *  ，优先级⾼的线程⽐优先级低的线程会有更⼤的⼏率优先执⾏。在 优先级相同的情况下，按照“先到先得”的原则。
 *  每个Java程序都有⼀个默认的主线 程，就是通过JVM启动的第⼀个线程main线程
 *
 *  守护线程：
 *  如果某线程是守护线程，那如果所有的⾮守护线程结束，这个守护线程也会
 * ⾃动结束。 应⽤场景是：当所有⾮守护线程结束时，结束其余的⼦线程（守护线程）⾃
 * 动关闭，就免去了还要继续关闭⼦线程的麻烦。
 * ⼀个线程默认是⾮守护线程，可以通过Thread类的setDaemon(boolean on)
 * 来设置。
 *
 * java线程的6个状态
 * public enum State {
 *  NEW,       新建
 *  RUNNABLE,  运行
 *  BLOCKED,      阻塞
 *  WAITING,      等待
 *  TIMED_WAITING,     超时等待
 *  TERMINATED;      终止
 * }
 *
 * 关于start()的两个引申问题
 * 1. 反复调⽤同⼀个线程的start()⽅法是否可⾏？
 * 2. 假如⼀个线程执⾏完毕（此时处于TERMINATED状态），再次调⽤这个线程 的start()⽅法是否可⾏？
 * 都不可行
 *
 * 线程中断
 * 在某些情况下，我们在线程启动后发现并不需要它继续执⾏下去时，需要中 断线程。⽬前在Java⾥还没有安全直接
 * 的⽅法来停⽌线程，但是Java提供了
 * 线程中断机制来处理需要中断线程的情况。
 * 线程中断机制是⼀种协作机制。需要注意，通过中断操作并不能直接终⽌⼀ 个线程，⽽是通知需要被中断的线程⾃⾏处理。
 *
 * Thread.interrupt()：中断线程。这⾥的中断线程并不会⽴即停⽌线程，⽽是设
 * 置线程的中断状态为true（默认是flase）；
 * Thread.interrupted()：测试当前线程是否被中断。线程的中断状态受这个⽅法 的影响，意思是调⽤⼀次使线程中断状态设置为true，连续调⽤两次会使得这 个线程的中断状态重新转为false；
 * Thread.isInterrupted()：测试当前线程是否被中断。与上⾯⽅法不同的是调⽤ 这个⽅法并不会影响线程的中断状态。
 *
 *
 * java线程间的通信
 * 锁与同步
 * 锁的概念基于对象，对象锁-------一个多在同时间只能被一个对象持有
 * 线程同步是线程之间按照⼀定的顺序执⾏。
 *
 *
 * 等待通知机制
 * Java多线程的等待/通知机制是基于 Object 类的 wait() ⽅法和 notify() ,
 * notifyAll() ⽅法来实现的。
 * notify()⽅法会随机叫醒⼀个正在等待的线程，⽽notifyAll()会叫醒所有正在等 待的线程。
 *
 * 信号量：
 *  volitile关键字能够保证内存的可⻅性，如果⽤volitile关键字声明了⼀个变 量，在⼀个线程⾥⾯改变了这个变量的值，那其它线程是⽴⻢可⻅更改后的 值的。
 *
 *  管道：
 *      基于“管道流”的通信方式。
 *      JDK提供了 PipedWriter 、 PipedReader 、
 * PipedOutputStream 、 PipedInputStream 。其中，前⾯两个是基于字符的，后⾯两 个是基于字节流的。
 *
 * 其他通信相关：
 * join()是Thread类的一个方法。作用是让当前线程陷入“等待”状态，等join这个线程执行完毕后，再执行
 * sleep()是Thread类的一个静态方法，作用是让当前线程睡眠一段时间 Thread.sleep(Long)
 * sleep⽅法是不会释放当前的锁的，⽽wait⽅法会
 * wait可以指定时间，也可以不指定；⽽sleep必须指定时间。
 * wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易 死锁。
 * wait必须放在同步块或同步⽅法中，⽽sleep可以再任意位置
 * ThreadLocal类
 * ThreadLocal是⼀个本地线程副本变量⼯具类。内部是⼀个弱引⽤的Map来维护。
 * 最常⻅的ThreadLocal使⽤场景为⽤来解决数据库连接、Session管理等。数据库连 接和Session管理涉及多个复杂对象的初始化和关闭。
 * 如果在每个线程中声明⼀些 私有变量来进⾏操作，那这个线程就变得不那么“轻量”了，需要频繁的创建和关闭 连接。
 *  InheritableThreadLocal
 *  InheritableThreadLocal类与ThreadLocal类稍有不同，Inheritable是继承的意思。 它不仅仅是当前线程可以存取副本值，
 *  ⽽且它的⼦线程也可以存取这个副本值。
 *
 *
 *  并发编程模型的两个关键问题
 *  线程间如何进行通信？
 *  线程间如何进行同步？            如何通信             如何同步
 *          消息传递模型         通过发送消息           发送消息天然同步
 *          共享内存模型        线程间共享程序的公       必须显示指定某段代码在线程间互斥执行
 *                            共状态通过写-读内容
 *                            间公共状态隐士
 *
 *
 * java内存模息型的抽象结构
 * 从图中可以看出： 1. 所有的共享变量都存在主内存中。 2. 每个线程都保存了⼀份该线程使⽤到的共享变量的副本。 3. 如果线程A与线程B之间要通信的话，必须经历下⾯2个步骤： i. 线程A将本地内存A中更新过的共享变量刷新到主内存中去。
 * ii. 线程B到主内存中去读取线程A之前已经更新过的共享变量。 所以，线程A⽆法直接访问线程B的⼯作内存，线程间通信必须经过主内存。 注意，根据JMM的规定，线程对共享变量的所有操作都必须在⾃⼰的本地内存中进 ⾏，不能直接从主内存中读取。
 *
 * 区别两者是不同的概念层次。JMM是抽象的，他是⽤来描述⼀组规则，通过这个规 则来控制各个变量的访问⽅式，围绕原⼦性、有序性、可⻅性等展开的。⽽
 * Java运⾏时内存的划分是具体的，是JVM运⾏Java程序时，必要的内存划分。 联系都存在私有数据区域和共享数据区域。⼀般来说，JMM中的主内存属于共享数
 * 据区域，他是包含了堆和⽅法区；同样，JMM中的本地内存属于私有数据区 域，包含了程序计数器、本地⽅法栈、虚拟机栈。
 *
 *重排序和happens-before
 * 编译器优化重排
 *        编译器在不改变单线程程序予语义的前提下，可以重新安排语句的执行顺序
 * 指令并行重排
 *        现代处理器采⽤了指令级并⾏技术来将多条指令重叠执⾏。如果不存在数据依 赖性(即后⼀个执⾏的语句⽆需依赖前⾯执⾏的语句的结果)，处理器可以改变 语句对应的机器指令的执⾏顺序。
 * 内存系统重排
 *        由于处理器使⽤缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看 上去可能是在乱序执⾏，因为三级缓存的存在，导致内存与缓存的数据同步存 在时间差。
 *
 *数据竞争：
 *      一个线程中写一个内存变量，在另一个线程中读同一个变量，并且读与写没有通过同步来排序
 *
 * happens-before
 * 定义：
 * 1. 如果⼀个操作happens-before另⼀个操作，那么第⼀个操作的执⾏结果将对第 ⼆个操作可⻅，⽽且第⼀个操作的执⾏顺序排在第⼆个操作之前。
 * 2. 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必 须要按照happens-before关系指定的顺序来执⾏。如果重排序之后的执⾏结 果，与按happens-before关系来执⾏的结果⼀致，那么JMM也允许这样的重 排序。
 * 天然的happens-before关系 在Java中，有以下天然的happens-before关系： 程序顺序规则：⼀个线程中的每⼀个操作，happens-before于该线程中的任意 后续操作。 监视器锁规则：对⼀个锁的解锁，happens-before于随后对这个锁的加锁。
 * volatile变量规则：对⼀个volatile域的写，happens-before于任意后续对这个
 * volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happensbefore C。
 * start规则：如果线程A执⾏操作ThreadB.start()启动线程B，那么A线程的
 * ThreadB.start（）操作happens-before于线程B中的任意操作、
 * join规则：如果线程A执⾏操作ThreadB.join（）并成功返回，那么线程B中的 任意操作happens-before于线程A从ThreadB.join()操作成功返回。
 *
 * volatile的内存语义
 * 保证变量的内存可⻅性
 * 禁⽌volatile变量与普通变量重排序（JSR133提出，Java 5 开始才有这个“增强 的volatile内存语义”）
 *
 * 内存可⻅性，指的是当⼀个线程对 volatile 修饰的变量进⾏写操作（⽐如
 * step 2）时，JMM会⽴即把该线程对应的本地内存中的共享变量的值刷新到主内 存；
 * 当⼀个线程对 volatile 修饰的变量进⾏读操作（⽐如step 3）时，JMM会把
 * ⽴即该线程对应的本地内存置为⽆效，从主内存中读取共享变量的值。
 *
 * 内存屏障：
 * 读屏障和写屏障
 *  阻⽌屏障两侧的指令重排序； 2. 强制把写缓冲区/⾼速缓存中的脏数据等写回主内存，或者让缓存中相应的数据
 * 失效。
 * volatile可以保证内存可⻅性且禁⽌重排序。
 *
 * 1. 如果第⼀个操作是volatile读，那⽆论第⼆个操作是什么，都不能重排序；
 * 2. 如果第⼆个操作是volatile写，那⽆论第⼀个操作是什么，都不能重排序；
 * 3. 如果第⼀个操作是volatile写，第⼆个操作是volatile读，那不能重排序。
 *
 * 我们通常使⽤ synchronized 关键字来给⼀段代码或⼀个⽅法上锁。它通常有以下 三种形式：
 * // 关键字在实例⽅法上，锁为当前实例
 * public synchronized void instanceLock() {
 *  // code
 * }volatile
 * // 关键字在静态⽅法上，锁为当前Class对象
 * public static synchronized void classLock() {
 *  // code
 * }
 * // 关键字在代码块上，锁为括号⾥⾯的对象
 * public void blockLock() {
 *  Object o = new Object();
 *  synchronized (o) {
 *  // code
 *  }
 * }
 *
 * 临界区：一段代码块，只能在同一时刻被同一线程执行
 * 锁：
 * Java 6 为了减少获得锁和释放锁带来的性能消耗，引⼊了“偏向锁”和“轻量级锁“。
 * java6一个对象实际是4中锁状态
 * 无锁状态
 * 偏向锁状态
 * 轻量级锁状态
 * 重量级锁状态
 *
 * java的锁都是基于对象的
 * java对象都有对象头
 * 偏向锁：
 * 锁不仅存在多线程之间的竞争，也存在总是由同一线程多次获得，偏向锁总是会偏向第一个访问锁的线程
 * 该锁没有被其 他的线程访问，则持有偏向锁的线程将永远不需要触发同步。偏向锁在 资源⽆竞争情况下消除了同步语句，连CAS操作都不做了，
 * 提⾼了程序的运⾏性 能。
 *
 * CAS: Compare and Swap
 * ⽐较并设置。⽤于在硬件层⾯上提供原⼦性操作。
 * 在 Intel 处理器中，⽐较并 交换通过指令cmpxchg实现。 ⽐较是否和给定的数值⼀致，如果⼀致则修 改，不⼀致则不修改。
 *
 *
 *                 优点                    缺点                        使用场景
 *
 * 偏向锁         加锁和解锁不需要额外的消耗，  如果线程间存在锁竞争，会        只有一个线程访问同步代码块
 *               和执行非同步方法            带来额外的消耗
 *
 * 轻量级锁       竞争的线程不会阻塞，提高了程序  如果始终得不到锁竞争的线程     追求响应时间，同步块执行速度
 *               响应的速度                   使用自旋会消耗cpu            非常快
 *
 * 重量级锁       线程竞争不使用自旋、不会消耗cpu   线程阻塞。响应时间缓慢      追求吞吐量 同步块执行速度较快
 *
 * 乐观锁和悲观锁
 *
 * 悲观锁：
 *      总是认为每次访问共享资源时会发生冲突。所以每次都对数据加上锁
 * 乐观锁：
 *      无锁：乐观锁⼜称为“⽆锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问 没有冲突，线程可以不停地执⾏，⽆需加锁也⽆需等待。
 *      ⽽⼀旦多个线程发⽣冲 突，乐观锁通常是使⽤⼀种称为CAS的技术来保证线程执⾏的安全性。
 *
 *      乐观锁多⽤于“读多写少“的环境，避免频繁加锁影响性能；⽽悲观锁多⽤于”写多读少“的环境，避免频繁失败和重试影响性能。
 *      如果有⼀个多个线程共享的变量 i 原本等于5，我现在在线程A中，想把它设 置为新的值6;
 *      2. 我们使⽤CAS来做这个事情； 3. ⾸先我们⽤i去与5对⽐，发现它等于5，说明没有被其它线程改过，那我就把 它设置为新的值6，此次CAS成功， i 的值被设置成了6； 4. 如果不等于5，说明 i 被其它线程改过了（⽐如现在 i 的值为2），那么我就
 *      什么也不做，此次CAS失败， i 的值仍然为2。
 *
 *      有几个问题
 *      1.ABA问题   就是⼀个值原来是A，变成了B，⼜变回了A。这个时候使⽤CAS是 检查不出变化的，但实际上却被更新了两次。
 * ABA问题的解决思路是在变量前⾯追加上版本号或者时间戳
 *      2. 循环时间⻓开销⼤  CAS多与⾃旋结合。如果⾃旋CAS⻓时间不成功，会占⽤⼤量的CPU资源。 解决思路是让JVM⽀持处理器提供的pause指令。
 *      3.只能保证⼀个共享变量的原⼦操作
 *
 *      RPC(remote procedure call)远程过程调用
 *
 *      动态规划：
 *      贪心算法
 *
 *      HashMap的数据结构？
 *      java7使用的是数组+链表，java8使用的是数据+链表+红黑树。
 *      HashMap的工作原理？
 *
 *
 *      springsecurity：是一个提供身份验证，授权和保护以防止常见攻击的框架
                        加密算法：单向的
        jwt：JWT实现认证和授权的原理：
                用户调用登录接口，登录成功后获取到JWT的token；
                之后用户每次调用接口都在http的header中添加一个叫Authorization的头，值为JWT的token；
                后台程序通过对Authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权。
            特点：token保存在客户端，而不是服务端！！！
            JWT token的格式：header.payload.signature
            header中用于存放签名的生成算法
            payload中用于存放用户名、token的生成时间和过期时间
            signature为以header和payload生成的签名，
            一旦header和payload被篡改，验证将失败
        shiro
 *
 *
 *
 * /

     }
